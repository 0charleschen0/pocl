#!/usr/bin/env python3
# -*- coding: utf8 -*-

# Copyright (c) 2013 Victor Oliveira <victormatheus@gmail.com>
# Copyright (c) 2013 Jesse Towner <jessetowner@lavabit.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

all_types = ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'long', 'ulong', 'float', 'double']
int_types = ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'long', 'ulong']
signed_types = ['char', 'short', 'int', 'long', 'float', 'double']
unsigned_types = ['uchar', 'ushort', 'uint', 'ulong']
int32_types = ['char', 'uchar', 'short', 'ushort', 'int', 'uint']
int64_types = ['long', 'ulong']
float_types = ['float', 'double']
vector_sizes = ['', '2', '4', '8', '16']
rounding_modes = ['','_rte','_rtz','_rtp','_rtn']

limit_max = {'char'  : 'CHAR_MAX',
             'uchar' : 'UCHAR_MAX',
             'short' : 'SHRT_MAX',
             'ushort': 'USHRT_MAX',
             'int'   : 'INT_MAX',
             'uint'  : 'UINT_MAX',
             'long'  : 'LONG_MAX',
             'ulong' : 'ULONG_MAX'}

limit_min = {'char'  : 'CHAR_MIN',
             'uchar' : '0',
             'short' : 'SHRT_MIN',
             'ushort': '0',
             'int'   : 'INT_MIN',
             'uint'  : '0',
             'long'  : 'LONG_MIN',
             'ulong' : '0'}

float_suffix = {'float': 'f', 'double': ''}
float_int_type = {'float': 'int', 'double': 'long'}

printf_format_type = {
             'char'  : '%#.2hhx',
             'uchar' : '%#.2hhx',
             'short' : '%#.4hx',
             'ushort': '%#.4hx',
             'int'   : '%#.8x',
             'uint'  : '%#.8x',
             'long'  : '%#.16lx',
             'ulong' : '%#.16lx',
             'float' : '%.12g',
             'double': '%.18g'}

def generate_conversions(src_types, dst_types):
  for src in src_types:
    for dst in dst_types:
      for size in vector_sizes:
        yield (src, dst, size)

def print_int64_ifdef(t):
  if t in int64_types:
    print("\n#ifdef cles_khr_int64")

def print_int64_endif(t):
  if t in int64_types:
    print("\n#endif")

#
# file header
#

print("""/* !!!! AUTOGENERATED FILE generated by test_convert_type.py !!!!!

   DO NOT CHANGE THIS FILE. MAKE YOUR CHANGES TO test_convert_type.py AND RUN:
   $ python3 test_convert_type.py > test_convert_type.cl
*/
""")

#
# integer value tables
#

for types in [int32_types, int64_types]:
  if types == int64_types:
    print("\n#ifdef cles_khr_int64")
  for t in types:
    values = ["0", "1", limit_min[t], limit_max[t], limit_min[t] + " / 2", limit_max[t] + " / 2"]
    print("constant {0} {0}_values[{1}] = {{ ".format(t, len(values)), end="")
    print(*values, sep=", ", end=" };\n")
  print()
  for t in types:
    print("const size_t {0}_values_length = sizeof({0}_values) / sizeof({0}_values[0]);".format(t))
  if types == int64_types:
    print("\n#endif")

#
# floating-point value tables
#

for f in float_types:
  if f == 'double':
    print("\n#ifdef cl_khr_fp64")
  print("""
{F} {F}_values[16] =
{{
  -2.0{S}, -1.75{S}, -1.5{S}, -1.25{S}, -1.0{S}, -0.75{S}, -0.5{S}, -0.25{S},
   0.0{S},  0.25{S},  0.5{S},  0.75{S},  1.0{S},  1.25{S},  1.5{S},  1.75{S}
}};

const size_t {F}_values_length = sizeof({F}_values) / sizeof({F}_values[0]);
{I} {F}_rounded_values[16] = {{ -2, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 }};
{I} {F}_rounded_values_rtz[16] = {{ -2, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1 }};
{I} {F}_rounded_values_rte[16] = {{ -2, -2, -2, -1, -1, -1, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2 }};
{I} {F}_rounded_values_rtp[16] = {{ -2, -1, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2 }};
{I} {F}_rounded_values_rtn[16] = {{ -2, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 0, 1, 1, 1, 1 }};
""".format(F=f, S=float_suffix[f], I=float_int_type[f]))
  if f == 'double':
    print("\n#endif")

#
# integer comparison functions
#

for t in int_types:
  print_int64_ifdef(t)
  print("""
__attribute__((__noinline__))
void compare_{Type}_elements(char const* name, const {Type}* expected, const {Type}* actual, size_t n)
{{
  for (size_t i = 0; i < n; ++i) {{
    if (expected[i] != actual[i]) {{
      printf("FAIL: %s - element #: %zu expected: {TypeFormat} actual: {TypeFormat}\\n", name, i, expected[i], actual[i]);
      break;
    }}
  }}
}}""".format(Type=t, TypeFormat=printf_format_type[t]))
  print_int64_endif(t)

#
# conversion tests
#

print("\nkernel void test_convert_type()\n{", end="")

#
# integer to integer conversions, with and without saturation
#

for (src, dst, size) in generate_conversions(int_types, int_types):
  if (src in int64_types) or (dst in int64_types):
    print("\n#ifdef cles_khr_int64")
  print("""
  for (size_t i = 0; i < {S}_values_length; ++i) {{
    const {S} min_expected = ({DMIN} > {SMIN}) ? ({S}){DMIN} : {SMIN};
    const {S} max_expected = ({DMAX} < {SMAX}) ? ({S}){DMAX} : {SMAX};
    union {{ {D}{N} value; {D} raw[{M}]; }} expected, actual;
    expected.value = (({D}{N})(({D}){S}_values[i]));
    actual.value = convert_{D}{N}(({S}{N}){S}_values[i]);
    compare_{D}_elements("convert_{D}{N}(({S}{N}))", expected.raw, actual.raw, {M});
    if ({S}_values[i] < min_expected) {{
       expected.value = ({D}{N})min_expected;
    }}
    else if ({S}_values[i] > max_expected) {{
       expected.value = ({D}{N})max_expected;
    }}
    actual.value = convert_{D}{N}_sat(({S}{N}){S}_values[i]);
    compare_{D}_elements("convert_{D}{N}_sat(({S}{N}))", expected.raw, actual.raw, {M});
  }}""".format(
      S=src, SMIN=limit_min[src], SMAX=limit_max[src],
      D=dst, DMIN=limit_min[dst], DMAX=limit_max[dst],
      N=size, M=size if len(size) > 0 else "1"))
  if (src in int64_types) or (dst in int64_types):
    print("\n#endif")

#
# floating-point to integer conversions
#

for (src, dst, size) in generate_conversions(float_types, int_types):
  if (src == 'double') or (dst in int64_types):
    print("\n#ifdef cl_khr_fp64")
  print("""
  for (size_t i = 0; i < {S}_values_length; ++i) {{
    union {{ {D}{N} value; {D} raw[{M}]; }} expected, actual;""".format(
      S=src, D=dst, N=size, M=size if len(size) > 0 else "1"))
  for mode in rounding_modes:
    print("""    expected.value = (({D}{N})(({D}){S}_rounded_values{R}[i]));
    actual.value = convert_{D}{N}{R}(({S}{N}){S}_values[i]);
    compare_{D}_elements("convert_{D}{N}{R}(({S}{N}))", expected.raw, actual.raw, {M});""".format(
      S=src, D=dst, R=mode, N=size, M=size if len(size) > 0 else "1"))
  print("  }");
  if (src == 'double') or (dst in int64_types):
    print("\n#endif")

#
# end conversion tests
#

print("}")

