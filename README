This directory tree holds Portable OpenCL (pocl), a (still in-development)
implementation of OpenCL standard which can be easily adapted for new targets.

The file INSTALL in this directory says how to build and install packages
which use the GNU build system, most of which is valid for the pocl
distribution.

This file provides additional information on required software packages,
special configure flags pocl might use, running pocl examples and using
pocl as the OpenCL implementation with any program that uses OpenCL. It
also describes the "standalone compilation mode" which might be used to
statically link kernels with the host program, and how to call any
host C library or syscall in your kernels which might be useful for
kernel debugging (see HOST LIBRARY CALLS).


EXAMPLES

After the build is complete, a number of examples are ready to be run on
the subdirectories under examples/. To run them, just go to each directory
and run the executable there (executable name matches subdirectory name).

    example1      Dot product example from OpenCL specification
    example2      Matrix transpose example from OpenCL specification
    barriers      Simple barrier synchronization exampls
    forloops      Simple example wth for loops inside the kernel
    standalone    Non-executable standalone example (see STANDALONE section)
    trig          Example using various trigonometric functions
    scalarwave    Example evolving the scalar wave equation


LINKING YOUR PROGRAM WITH POCL

During installation, pocl places a copy of standard OpenCL headers in
<prefix>/include/CL if no OpenCL headers was already available at configure
time.

There are two ways to link your program to pocl: directly or through an ICD
loader.

LINKING YOUR PROGRAM WITH POCL DIRECTLY

Passing the appropriate linker flags is enough to use pocl in your
program. However, please bear in mind that:

    1. The current distribution only supports one device, "native",
       which runs the kernels in the host system.
    2. Current implementation of both host and kernel runtime libraries
       is far for complete. If your program uses any of the unimplemented
       API calls, it will not work. Please implement the mssing APIs
       when you need them and submit us a patch :)

The pkg-config tool is used to locate the libraries and headers in
the installation directory. 

Example of compiling an OpenCL host program against pocl using
the pkg-config:

gcc example1.c -o example `pkg-config --libs --cflags pocl`

In this link mode, your program will always require the pocl OpenCL library. It
wont be able to run with another OpenCL implementation without recompilation.

Pocl needs to be configurated with the --enable-direct-linkage option (enabled
by default)

LINKING YOUR PROGRAM WITH POCL THROUGH AN ICD LOADER

You can link your OpenCL program against an ICD loader. If your ICD loader is
correctly configurated to load pocl, your program will be able to use pocl.
See "INSTALLABLE CLIENT DRIVER (ICD)" below for more information about ICD and 
ICD loaders.

Example of compiling an OpenCL host program using the free ocl-icd loader:

gcc example1.c -o example `pkg-config --libs --cflags OpenCL`

Example of compiling an OpenCL host program using the AMD ICD loader (no
pkg-config support):

gcc example1.c -o example -lOpenCL

STANDALONE

The "standalone compilation mode" is especially useful for embedded standalone 
platforms which do not include an operating system with a dynamic linker
and still want to run OpenCL programs to exploit the language's parallelism.

The key idea in the standalone mode is to link the OpenCL kernels statically 
to the host program and make the kernels appear in the "kernel registry" of 
the host API so they can be lauched from the main program without needing to
invoke the runtime kernel compilation. 

The original targets of this method are the application-specific TTA processors 
designed with the TTA-Based Co-design Environment (http://tce.cs.tut.fi) which 
now uses pocl for kernel compilation. TCE's compiler driver script tcecc serves 
as an example how to register and launch the kernels seamlessly in the 
compilation/linkage chain of standalone OpenCL programs.

The 'pocl-standalone' script can be used to compile OpenCL C kernels separately
to be linked with the main program in this setting.

HOST LIBRARY CALLS

When using the "native" device that runs the kernels on the host (after
statically replicating their work items), the kernels might use any
library or system call in the host. The examples "barriers" and "forloops"
show how to call "printf" inside the kernel, but any other host function 
can be called as well. This can prove quite useful when debugging OpenCL 
kernels.

KERNEL REPLICATION

(todo)

INSTALLABLE CLIENT DRIVER (ICD)

Pocl is built with the ICD extensions of OpenCL by default if development files
of ocl-icd are found at configure time. This allows you to have several OpenCL
implementations concurrently on your computer, and select the one to use at
runtime by selecting the corresponding cl_platform. ICD support can be disabled
by adding the flag

  --disable-icd

to the ./configure script.

In case you also give the --prefix=$INSTALL option to ./configure, you need to 
copy the icd file to where your ICD loader finds it:
  cp $INSTALL/etc/OpenCL/vendors/pocl.icd /etc/OpenCL/vendors/pocl.icd

The ocl-icd ICD loader allows to use the OCL_ICD_VENDORS environment variable
to specify a (non standard) replacement of the /etc/OpenCL/vendors directory.

An ICD loader is an OpenCL library acting as a demultiplexor to various OpenCL
implementations. Pocl does not provide an ICD loader itself, but NVidia, AMD,
Intel and the free ocl-icd project each provides one.
